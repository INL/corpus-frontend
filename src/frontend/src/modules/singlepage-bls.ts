import $ from 'jquery';
import URI from 'urijs';

import {getState, get} from '@/store';
import {debugLog} from '@/utils/debug';
import * as BLTypes from '@/types/blacklabtypes';

/**
 * Converts page state into a query for blacklab-server and executes it.
 * Also handles getting data such as longer snippets, concordances, etc.
 */

// TODO update documentation
/**
 * Converts the active filters into a parameter string blacklab-server can understand.
 *
 * Values from filters with types other than 'range' or 'select' will be split on whitespace and individual words will be surrounded by quotes.
 * Effectively transforming
 * "quoted value" not quoted value
 * into
 * "quoted value" "not" "quoted" "value"
 *
 * The result of this is that the filter will respond to any value within one set of quotes, so practially an OR on individual words.
 *
 * If the array is empty or null, undefined is returned,
 * so it can be placed directly in the request paremeters without populating the object if the value is not present.
 */
export function getFilterString(params: RootState['form']['submittedParameters']): string|undefined {
	if (params == null || !params.filters.length) {
		return undefined;
	}

	const filterStrings = [] as string[];
	for (const filter of params.filters) {
		if (!filter.values.length) {
			continue;
		}

		if (filterStrings.length) {
			filterStrings.push(' AND ');
		}

		if (filter.type === 'range') {
			filterStrings.push(filter.id, ':', '[', filter.values[0], ' TO ', filter.values[1], ']');
		} else if (filter.type === 'select') {
			// Surround each individual value with quotes, and surround the total with brackets
			filterStrings.push(filter.id, ':', '("', filter.values.join('" "'), '")');
		} else {
			// Do the quoting thing
			const resultParts = [] as string[];

			$.each(filter.values, function(index, value) {
				const quotedParts = value.split(/"/);
				let inQuotes = false;
				for (let part of quotedParts) {
					if (inQuotes) {
						// Inside quotes. Add literally.
						resultParts.push(' "');
						resultParts.push(part);
						resultParts.push('"');
					} else {
						// Outside quotes. Surround each word with quotes.
						part = part.trim();
						if (part.length > 0) {
							const words = part.split(/\s+/);
							resultParts.push(' "');
							resultParts.push(words.join('" "'));
							resultParts.push('" ');
						}
					}
					inQuotes = !inQuotes;
				}
			});

			filterStrings.push(filter.id, ':', '(' + resultParts.join('').trim(), ')');
		}
	}

	return filterStrings.join('') || undefined;
}

export function getBlsParamFromState(): BLTypes.BlacklabParameters {
	const state = getState();

	const viewProps = get.viewedResultsSettings();
	if (viewProps == null) {
		throw new Error('Cannot generate blacklab parameters without knowing hits or docs');
	}

	const submittedParameters = state.form.submittedParameters;
	if (submittedParameters == null) {
		// Realistically we can... because we can use the current state of the ui
		// but this should never happen before the form is submitted, or after it has been cleared
		throw new Error('Cannot generate blacklab parameters before search form has been submitted');
	}

	return {
		filter: getFilterString(submittedParameters),
		first: state.settings.pageSize * viewProps.page,
		group: viewProps.groupBy.map(g => g + (viewProps.caseSensitive ? ':s':':i')).join(',') || undefined,
		// group: viewProps.groupBy.join(',') || undefined,
		number: state.settings.pageSize,
		patt: submittedParameters.pattern||undefined,

		sample: (state.settings.sampleMode === 'percentage' && state.settings.sampleSize) ? state.settings.sampleSize /* can't be null after check */ : undefined,
		samplenum: (state.settings.sampleMode === 'count' && state.settings.sampleSize) ? state.settings.sampleSize : undefined,
		sampleseed: (state.settings.sampleSeed != null && state.settings.sampleMode && state.settings.sampleSize) ? state.settings.sampleSeed : undefined,

		sort: viewProps.sort != null ? viewProps.sort : undefined,
		viewgroup: viewProps.viewGroup != null ? viewProps.viewGroup : undefined,
		wordsaroundhit: state.settings.wordsAroundHit != null ? state.settings.wordsAroundHit : undefined,
	};
}

import {RootState} from '@/store';

/**
 * Get a human-readable summary of the most important search parameters
 * Arguments must be equal to the same members of the SearchParameters object
 *
 * @param pattern - A direct CQL query string, or an array of simple search paremeters. This value MUST be present if operation === 'hits'
 * @param within - raw token name (i.e. not enclosed in </>) for the within clause (so 'p' for paragraph, 's' for sentence, etc), only used when typeof pattern === 'Array'
 * @param filters - Metadata filters as generated by singlepage-form.js, every filter is expected to have a valid value.
 */
export function getQuerySummary(params: RootState['form']['submittedParameters']) {
	if (params == null) {
		return 'all documents';
	}

	const queryString = params.pattern;
	const metadataString = params.filters.map(({id, type, values}) =>
		`${id} = [${type==='range'?`${values[0]} to ${values[1]}`:values.join(', ')}]`).join(', ');

	let ret = '';
	if (queryString) {
		ret += '"' + queryString + '"' + ' within ';
	}
	if (metadataString) {
		ret += 'documents where ' + metadataString;
	} else {
		ret += 'all documents';
	}

	return ret;
}

export default {};
