/**
 *
 */
package nl.inl.corpuswebsite.response;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.TransformerException;

import nl.inl.corpuswebsite.BaseResponse;
import nl.inl.corpuswebsite.MainServlet;
import nl.inl.corpuswebsite.utils.QueryServiceHandler;
import nl.inl.corpuswebsite.utils.QueryServiceHandler.QueryException;
import nl.inl.corpuswebsite.utils.UrlParameterFactory;
import nl.inl.corpuswebsite.utils.XslTransformer;

/**
 *
 */
public class ArticleResponse extends BaseResponse {

	/** For getting article */
	private QueryServiceHandler articleContentRequest = null;

	/** For getting metadata */
	private QueryServiceHandler articleMetadataRequest;

	private XslTransformer transformer = new XslTransformer();

	private String articleStylesheet;

	private String metadataStylesheet;


	public ArticleResponse() {
		super(true, null);
	}

	@Override
	public void init(HttpServletRequest request, HttpServletResponse response, MainServlet servlet, String corpus, String contextPathAbsolute, String uriRemainder) throws ServletException {
		super.init(request, response, servlet, corpus, contextPathAbsolute, uriRemainder);
	}

	@Override
	protected void completeRequest() {
		try {
			String corpusDataFormat = servlet.getCorpusConfig(corpus).getCorpusDataFormat();
			articleStylesheet = servlet.getStylesheet(corpus, corpusDataFormat);
			metadataStylesheet = servlet.getStylesheet(corpus, "meta");
		} catch (QueryException e) {
			// this might happen if the import format is deleted after a corpus was created.
			// then blacklab-server can obviously no longer generate the xslt based on the import format.
			// TODO clean this up, response should not have to clean up obscure errors from MainServlet.
			if (e.getHttpStatusCode() == 404) {
				// use a default xslt that just outputs all text
				articleStylesheet = metadataStylesheet =
				"<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
				"<xsl:stylesheet version=\"2.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">" +
				"<xsl:output encoding=\"utf-8\" method=\"html\" omit-xml-declaration=\"yes\" />" +
				"</xsl:stylesheet>";
			} else {
				throw new RuntimeException(e);
			}
		}


		String pid = this.getParameter("doc", "");

		if (pid == null || pid.isEmpty()) {
			try {
				response.sendError(HttpServletResponse.SC_NOT_FOUND);
				return;
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}

		articleContentRequest = new QueryServiceHandler(servlet.getWebserviceUrl(corpus) + "docs/" + pid + "/contents");
		articleMetadataRequest = new QueryServiceHandler(servlet.getWebserviceUrl(corpus) + "docs/" + pid);

		if (request.getParameterMap().size() > 0) {
			// get parameter values
			String query = this.getParameter("query", "");
			String userId = MainServlet.getCorpusOwner(corpus);

			Map<String, String[]> contentRequestParameters = UrlParameterFactory.getSourceParameters(query, null);
			Map<String, String[]> metadataRequestParameters = new HashMap<>();
			if (userId != null) {
				contentRequestParameters.put("userid", new String[] { userId });
                metadataRequestParameters.put("userid", new String[] { userId });
			}

			// show max. 5000 words of content (TODO: paging)
			// paging will also need edits in blacklab,
			// since when you only get a subset of the document without begin and ending, the top of the xml tree will be missing
			// and xslt will not match anything (or match the wrong elements)
			// so blacklab will have to walk the tree and insert those tags in some manner.
			contentRequestParameters.put("wordend", new String[] {"5000"});


			try {
				String xmlResult = articleContentRequest.makeRequest(contentRequestParameters);
				if (xmlResult.contains("NOT_AUTHORIZED")) {
					context.put("article_content", "");
				} else {
					transformer.clearParameters();
					transformer.addParameter("contextRoot", servlet.getServletContext().getContextPath());

					for (Entry<String, String> e : servlet.getWebsiteConfig(corpus).getXsltParameters().entrySet()) {
						transformer.addParameter(e.getKey(), e.getValue());
					}

					context.put("article_content", transformer.transform(xmlResult, articleStylesheet));
				}

				xmlResult = articleMetadataRequest.makeRequest(metadataRequestParameters);
				transformer.clearParameters();
				String htmlResult = transformer.transform(xmlResult, metadataStylesheet);
				context.put("article_meta", htmlResult);

			} catch (IOException e) {
				throw new RuntimeException(e);
			} catch (TransformerException e) {
				// TODO handle this, can be caused by faulty xslt generated by blacklab-server
				throw new RuntimeException(e);
			} catch (QueryException e) {
				if (e.getHttpStatusCode() == 404) {
					try {
						response.sendError(HttpServletResponse.SC_NOT_FOUND);
						return;
					} catch (IOException e1) {
						throw new RuntimeException(e1);
					}
				}
			}
		}

		// display template
		displayHtmlTemplate(servlet.getTemplate("article"));
	}

}
