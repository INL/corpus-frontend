package nl.inl.corpuswebsite.utils;

import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Optional;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.TransformerException;

import org.apache.commons.lang3.exception.ExceptionUtils;

import nl.inl.corpuswebsite.MainServlet;
import nl.inl.corpuswebsite.response.ArticleResponse;

public class CorpusFileUtil {

    /**
     * Get a file from the directory belonging to this corpus and return it, attempting to get a default if that fails.
     * User corpora never have their own directory, and so will only use the locations for the defaults.
     *
     * <pre>
     * Tries in several locations:
     * - First try PROP_DATA_PATH/corpus/ directory (if configured, and this is not a user corpus)
     * - Then try PROP_DATA_PATH/PROP_DATA_DEFAULT directory (if configured)
     * - Finally try WEB-INF/interface-default
     * </pre>
     *
     * @param filesDir - the root dir where per-corpus files are stored (so not already resolved to the corpus name)
     *                      (i.e. {@link nl.inl.corpuswebsite.utils.GlobalConfig.Keys#CORPUS_CONFIG_DIR })
     * @param corpus - corpus for which to get the file. If null or a user-defined corpus only the default locations are
     *         checked.
     * @param fallbackCorpus - for when the corpus does not exist, try this one instead (i.e. {@link nl.inl.corpuswebsite.utils.GlobalConfig.Keys#DEFAULT_CORPUS_CONFIG}).
     * @param filePath - path to the file relative to the directory for the corpus.
     * @return the file, if found
     */
    public static Optional<File> getProjectFile(String filesDir, Optional<String> corpus, Optional<String> fallbackCorpus, Optional<String> filePath) {
        Optional<Path> dataDir = getIfValid(filesDir);
        return dataDir
            // try the file in the corpus' own data directory,
            // (only when a valid non-user corpus)
            // (we don't support configuring user corpora)
            // There's no reason that couldn't work, but since users can't upload the files to do so anyway,
            // configure it, it's not worth the effort (and there might be a few gotchas with username to file path mapping).
            .filter(path -> !isUserCorpus(corpus))
            .flatMap(p -> resolveIfValid(p, corpus))
            .flatMap(p -> resolveIfValid(p, filePath))
            .map(Path::toFile)
            .filter(File::canRead)
            // if the lookup above didn't work, try the fallback corpus
            // see https://github.com/INL/corpus-frontend/pull/69
            // In essence, this can be used to supply a default config which also applies to user corpora
            // (albeit as a whole, not individually).
            .or(() -> dataDir
                .flatMap(p -> resolveIfValid(p, fallbackCorpus))
                .flatMap(p -> resolveIfValid(p, filePath))
                .map(Path::toFile)
                .filter(File::canRead)
            )
            // try default file inside .war
            // only available for a couple of standard items (search.xml, some builtin xslt files)
            .or(() -> {
                try {
                    URL url = MainServlet.class.getResource("/interface-default/" + filePath.get());
                    if (url == null) return Optional.empty();
                    URI uri = url.toURI();
                    return Optional.of(new File(uri)).filter(File::exists);
                } catch (URISyntaxException e) {
                    return Optional.empty();
                }
            });
    }


    /**
     * Get the stylesheet to convert a document or its metadata from this corpus into
     * an html snippet suitable for inserting in the article.vm page.
     *
     * First attempts to find file "${name}.xsl" in all locations, then,
     * as a fallback, attempts to find "${name}_${corpusDataFormat}.xsl" in all locations.
     * The data format suffix is supported to allow placing xsl files for all corpora in the same fallback directory.
     *
     * "meta.xsl" is used to transform the document's metadata, "article.xsl" for the content.
     * See {@link ArticleResponse}.
     *
     * Looks for a file by the name of "article_corpusDataFormat.xsl", so "article_tei" for tei, etc.
     * Separate xslt is used for metadata,
     *
     * <pre>
     * First tries retrieving the file using {@link #getProjectFile(String, Optional, Optional, Optional)}
     * If that fails, tries contacting blacklab-server for an autogenerated best-effort xsl file.
     *  - Note that this only returns something corpusDataFormat describes XML-based documents.
     * </pre>
     *
     * @param filesDir - top-level directory where per-corpus files are stored.
     * @param corpus - which corpus to load the file for
     * @param fallbackCorpus - if corpus is not found, try this one instead (for defaults)
     * @param name - the name of the file, excluding extension
     * @param corpusDataFormat - optional name suffix to differentiate files for different formats
     * @param request - the request, used to retrieve basic auth credentials for blacklab-server in case they're needed.
     * @param response - the response, used to return to the client when no credentials are available, and they're needed.
     * @return the xsl transformer to use for transformation, note that this is always the same transformer.
     */
    public static Result<XslTransformer, TransformerException> getStylesheet(String filesDir, Optional<String> corpus, Optional<String> fallbackCorpus, String name, Optional<String> corpusDataFormat, HttpServletRequest request, HttpServletResponse response) {
        Optional<String> filename = Optional.of(name + ".xsl");
        Optional<String> fallbackFilename = corpusDataFormat.map(f -> name + "_" + f + ".xsl");

        // resolve file on disk
        Optional<File> file = getProjectFile(filesDir, corpus, fallbackCorpus, filename)
                .or(() -> getProjectFile(filesDir, corpus, fallbackCorpus, fallbackFilename));

        // If file found, parse it
        Result<XslTransformer, TransformerException> r = Result
                .from(file)
                .mapWithErrorHandling(XslTransformer::new)
                .mapError(e -> new TransformerException(
                        "Error loading stylesheet from disk:\n"
                                + file.get() + "\n"
                                + e.getMessage() + "\n"
                                + ExceptionUtils.getStackTrace(e))
                );
        // If the file exists (i.e. we have a result or an error at this point), return it. Don't hide errors in the file by using BlackLab as a fallback (since we want to be able to debug errors in files on disk).
        if (!r.isEmpty()) return r;

        // alright, file not found. Try getting from BlackLab and parse that
        if (name.equals("article") && corpusDataFormat.isPresent()) { // for article files, we can try blacklab if there is no file on disk
            return new BlackLabApi(request, response)
                    .getStylesheet(corpusDataFormat.get())
                    .flatRecover(e -> e.getHttpStatusCode() == 404 ? Result.empty() : Result.error(e)) // if blacklab returns a 404, return empty instead of the http error.
                    .mapWithErrorHandling(XslTransformer::new)
                    .mapError(e -> new TransformerException(
                            "Error loading stylesheet " + corpusDataFormat + " from BlackLab:\n"
                                    + e.getMessage() + "\n"
                                    + ExceptionUtils.getStackTrace(e))
                    );
        }
        return Result.error(new TransformerException("File not found on disk, and no fallback available: " + name + ".xsl"));
    }

    private static Optional<Path> getIfValid(String path) {
        if (path == null || path.isEmpty())
            return Optional.empty();

        try {
            return Optional.of(Paths.get(path));
        } catch (InvalidPathException e) {
            return Optional.empty();
        }
    }

    /**
     * Resolve the child again the parent and verify that the child is indeed a descendant.
     * Also handle null, illegal paths, empty strings and other such things.
     *
     * @return the new path if everything is alright
     */
    private static Optional<Path> resolveIfValid(Path parent, Optional<String> child) {
        try {
            // prevent upward directory traversal - child must be in parent
            return child.map(parent::resolve).filter(resolved -> resolved.startsWith(parent) && !resolved.equals(parent));
        } catch (Exception e) { // catch anything, a bit lazy but allows passing in null and empty strings etc
            return Optional.empty();
        }
    }

    public static boolean isUserCorpus(Optional<String> corpus) {
        return getCorpusOwner(corpus).isPresent();
    }

    /** User corpora are identified by having a colon in their id separating username:corpusname */
    public static Optional<String> getCorpusName(Optional<String> corpus) {
        return corpus.map(id -> id.substring(Math.max(0, id.indexOf(':'))));
    }

    /** User corpora are identified by having a colon in their id separating username:corpusname */
    public static Optional<String> getCorpusOwner(Optional<String> corpus) {
        return corpus.map(id -> { int i = id.indexOf(':'); return i != -1 ? id.substring(0, i) : null; });
    }
}
