package nl.inl.corpuswebsite.utils;

import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Optional;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.TransformerException;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;

import nl.inl.corpuswebsite.MainServlet;
import nl.inl.corpuswebsite.response.ArticleResponse;
import nl.inl.corpuswebsite.utils.GlobalConfig.Keys;

public class CorpusFileUtil {

    /**
     * Get a file from the directory belonging to this corpus and return it, attempting to get a default if that fails.
     * User corpora never have their own directory, and so will only use the locations for the defaults.
     *
     * <pre>
     * Tries in several locations:
     * - First try PROP_DATA_PATH/corpus/ directory (if configured, and this is not a user corpus)
     * - Then try PROP_DATA_PATH/PROP_DATA_DEFAULT directory (if configured)
     * - Finally try WEB-INF/interface-default
     * </pre>
     *
     * @param filesDir - the root dir where per-corpus files are stored (so not already resolved to the corpus name)
     *                      (i.e. {@link nl.inl.corpuswebsite.utils.GlobalConfig.Keys#CORPUS_CONFIG_DIR })
     * @param corpus - corpus for which to get the file. If null or a user-defined corpus only the default locations are
     *         checked.
     * @param fallbackCorpus - for when the corpus does not exist, try this one instead (i.e. {@link nl.inl.corpuswebsite.utils.GlobalConfig.Keys#DEFAULT_CORPUS_CONFIG}).
     * @param filePath - path to the file relative to the directory for the corpus.
     * @return the file, if found
     */
    public static Optional<File> getProjectFile(String filesDir, Optional<String> corpus, Optional<String> fallbackCorpus, Optional<String> filePath) {
        Optional<Path> dataDir = getIfValid(filesDir);
        return dataDir
            // try the file in the corpus' own data directory,
            // (only when a valid non-user corpus)
            // (we don't support configuring user corpora)
            // There's no reason that couldn't work, but since users can't upload the files to do so anyway,
            // configure it, it's not worth the effort (and there might be a few gotchas with username to file path mapping).
            .filter(path -> !isUserCorpus(corpus))
            .flatMap(p -> resolveIfValid(p, corpus))
            .flatMap(p -> resolveIfValid(p, filePath))
            .map(Path::toFile)
            .filter(File::canRead)
            // if the lookup above didn't work, try the fallback corpus
            // see https://github.com/INL/corpus-frontend/pull/69
            // In essence, this can be used to supply a default config which also applies to user corpora
            // (albeit as a whole, not individually).
            .or(() -> dataDir
                .flatMap(p -> resolveIfValid(p, fallbackCorpus))
                .flatMap(p -> resolveIfValid(p, filePath))
                .map(Path::toFile)
                .filter(File::canRead)
            )
            // try default file inside .war
            // only available for a couple of standard items (search.xml, some builtin xslt files)
            .or(() -> {
                try {
                    URL url = MainServlet.class.getResource("/interface-default/" + filePath.get());
                    if (url == null) return Optional.empty();
                    URI uri = url.toURI();
                    return Optional.of(new File(uri)).filter(File::exists);
                } catch (URISyntaxException e) {
                    return Optional.empty();
                }
            });
    }

    /**
     * <pre>
     * Get the stylesheet to convert a document or its metadata from this corpus into
     * an html snippet suitable for inserting in the article.vm page.
     *
     * First attempts to find file "${name}_${corpusDataFormat}.xsl" in all locations, then,
     * as a fallback, attempts to find "${name}.xsl" in all locations.
     * The data format suffix is supported to allow placing xsl files for all corpora in the same fallback directory.
     * "meta.xsl" is conventionally used to transform the document's metadata, "article.xsl" for the content.
     * E.G.: "article_corpusDataFormat.xsl", so "article_tei" for tei, etc.
     * The regular "article.xsl" could be used as a global fallback.
     *
     * First tries retrieving the file using {@link #getProjectFile(String, Optional, Optional, Optional)}
     * If that fails, tries contacting BlackLab-server for an autogenerated best-effort xsl file.
     *  - Note that BlackLab only returns an xsl when the corpusDataFormat describes XML-based documents (i.e. not tsv, csv, plaintext, etc)
     * </pre>
     *
     * @param corpus - which corpus to load the file for.
     * @param fileName - the name of the file, excluding extension
     * @param request - the request, used to retrieve auth credentials for blacklab-server in case they're needed.
     * @param response - the response, used to return to the client when no credentials are available, and they're needed.
     * @param config - the global configuration, used to copy auth headers from the client request to the blacklab request.
     * @return the xsl transformer to use for transformation, note that this is always the same transformer.
     */
    public static Result<XslTransformer, TransformerException> getStylesheet(
            CorpusConfig corpus,
            GlobalConfig config,
            String fileName,
            HttpServletRequest request,
            HttpServletResponse response
    ) {
        Optional<String> fullFileName = corpus.getCorpusDataFormat().map(formatName -> fileName + "_" + formatName + ".xsl");
        Optional<String> fallbackFilename = Optional.of(fileName + ".xsl");
        String filesDir = config.get(Keys.CORPUS_CONFIG_DIR);
        Optional<String> fallbackDirectory = Optional.of(config.get(Keys.DEFAULT_CORPUS_CONFIG));

        // resolve file on disk
        Optional<File> file = getProjectFile(filesDir, Optional.of(corpus.getCorpusId()), fallbackDirectory, fullFileName)
                .or(() -> getProjectFile(filesDir, Optional.of(corpus.getCorpusId()), fallbackDirectory, fallbackFilename));

        // If file found, parse it
        Result<XslTransformer, TransformerException> r = Result
                .from(file)
                .mapWithErrorHandling(XslTransformer::new)
                .mapError(e -> new TransformerException(
                        "Error loading stylesheet from disk:\n"
                                + file.get() + "\n"
                                + e.getMessage() + "\n"
                                + ExceptionUtils.getStackTrace(e))
                );
        // If the file exists (i.e. we have a result or an error at this point), return it.
        // Don't hide errors in the file by using BlackLab as a fallback (since we want to be able to debug errors in files on disk).
        if (!r.isEmpty()) return r;

        // alright, file not found. Try getting from BlackLab and parse that
        if (fileName.equals("article") && corpus.getCorpusDataFormat().isPresent()) { // for article files, we can try blacklab if there is no file on disk
            return new BlackLabApi(request, response, config)
                    .getStylesheet(corpus.getCorpusDataFormat().get())
                    .flatRecover(e -> e.getHttpStatusCode() == 404 ? Result.empty() : Result.error(e)) // if blacklab returns a 404, return empty instead of the http error.
                    .mapWithErrorHandling(xsl -> new XslTransformer(corpus.getCorpusDataFormat().get(), xsl))
                    .mapError(e -> new TransformerException(
                            "Error loading stylesheet " + corpus.getCorpusDataFormat().get() + " from BlackLab:\n"
                                    + e.getMessage() + "\n"
                                    + ExceptionUtils.getStackTrace(e))
                    );
        }
        return Result.error(new TransformerException("File not found on disk, and no fallback available: " + fileName + ".xsl"));
    }

    private static Optional<Path> getIfValid(String path) {
        if (path == null || path.isEmpty())
            return Optional.empty();

        try {
            return Optional.of(Paths.get(path));
        } catch (InvalidPathException e) {
            return Optional.empty();
        }
    }

    /**
     * Resolve the child again the parent and verify that the child is indeed a descendant.
     * Also handle null, illegal paths, empty strings and other such things.
     *
     * @return the new path if everything is alright
     */
    private static Optional<Path> resolveIfValid(Path parent, Optional<String> child) {
        try {
            // prevent upward directory traversal - child must be in parent
            return child.map(parent::resolve).filter(resolved -> resolved.startsWith(parent) && !resolved.equals(parent));
        } catch (Exception e) { // catch anything, a bit lazy but allows passing in null and empty strings etc
            return Optional.empty();
        }
    }

    public static boolean isUserCorpus(Optional<String> corpus) {
        return getCorpusOwner(corpus).isPresent();
    }

    /** User corpora are identified by having a colon in their id separating username:corpusname */
    public static Optional<String> getCorpusName(Optional<String> corpus) {
        return corpus.map(id -> StringUtils.substringAfter(id, ":")).map(StringUtils::trimToNull).or(() -> corpus);
    }

    /** User corpora are identified by having a colon in their id separating username:corpusname */
    public static Optional<String> getCorpusOwner(Optional<String> corpus) {
        return corpus.map(id -> {
            String[] parts = StringUtils.split(id, ":");
            return parts.length > 1 ? parts[0] : null;
        }).map(StringUtils::trimToNull);
    }
}
