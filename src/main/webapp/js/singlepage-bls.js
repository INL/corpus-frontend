/* global BLS_URL, URI, lucenequeryparser */

/**
 * @typedef {Object} SearchParameters
 *
 * @property {('hits' | 'docs')} operation - The main type of data to request, is transformed to the path of the search url, as in blacklab-server/corpusId/<operation>?parameters
 * @property {(string | Array.<PropertyField>)} [pattern] - A direct CQL query string, or an array of simple search parameters. This value MUST be present if operation === 'hits'
 * @property {string} within - raw token name (i.e. not enclosed in </>) for the within clause (so 'p' for paragraph, 's' for sentence, etc), only used when typeof pattern === 'Array'
 * @property {string} sampleSize - how many hits/docs, or what percentage to sample
 * @property {('percentage' | 'count')} sampleMode - meaning of sampleSize
 * @property {string} sampleSeed - seed for the random sampling
 * @property {number} page - Which page to request, does not necessarily have to be a whole number.  Used to calculate 'number' and 'first'
 * @property {number} pageSize - How many results to request. Should be a whole number. Used to calculate 'number' and 'first'
 * @property {Array.<FilterField>} [filters] - Metadata filters as generated by singlepage-form.js, every filter is expected to have a valid value.
 * @property {Array.<string>} [groupBy] - Array of valid group types, will be sent as a comma-separated list.
 * @property {string} [viewGroup] - Get results of a specific group instead of an overview of all groups. groupBy MUST be set when this parameter is set.
 * @property {string} [sort] - what fields to sort by.
 */

/**
  * BlackLab Parameters as generated by getBlsParam. Is a stricter subset of query parameters blacklab accepts.
  *
  * @typedef {Object} BlackLabParameters
  *
  * @property {number} number - number of results to request
  * @property {number} first - index of first result to request
  * @property {number} [sample] - percentage of results to return (0-100), mutually exclusive with 'samplenum'
  * @property {number} [samlenum] - how many results to return, mutually exclusive with 'sample'
  * @property {number} [sampleseed] - seed from which the samples are generated
  * @property {string} [filter]
  * @property {string} [group] - how to group results
  * @property {string} [patt] - CQL query
  * @property {string} [sort]
  * @property {string} [viewgroup] - also return results within this specific group (only when 'group' specified)
  */

var SINGLEPAGE = SINGLEPAGE || {};

/**
 * Converts search parameters into a query for blacklab-server and executes it.
 * Also handles getting data such as longer snippets, concordances, etc.
 */
SINGLEPAGE.BLS = (function () {
	'use strict';

	function makeWildcardRegex(original) {
		return original
			.replace(/([\^$\-\\.(){}[\]+])/g, '\\$1') // add slashes for regex characters
			.replace(/\*/g, '.*') // * -> .*
			.replace(/\?/g, '.'); // ? -> .
	}

	function makeRegexWildcard(original) {
		var a = original;
		a=a.replace(/\\([\^$\-\\(){}[\]+])/g, '$1'); // remove most slashes
		a=a.replace(/\\\./g, '_ESC_PERIOD_'); // escape \.
		a=a.replace(/\.\*/g, '*'); // restore *
		a=a.replace(/\./g, '?'); // restore ?
		a=a.replace(/_ESC_PERIOD_/g, '.'); // unescape \. to .
		return a;
	}

	/**
	 * Converts an array of PropertyFields to a cql token string.
	 * If pattern is a string already, it is returned as-is.
	 * Every PropertyField value is split on whitespace, and every word is mapped to a token with the same index.
	 * I.E. lemma="multiple words" is converted to [lemma="multiple"][lemma="words"]
	 * Values are converted from wildcard to regex, and case sensitivity flags are inserted where case-sensitive searching is specified.
	 * @param {(string | Array.<PropertyField>)} pattern
	 * @param {string} within - raw token name (i.e. not enclosed in </>) for the within clause (so 'p' for paragraph, 's' for sentence, etc), only used when typeof pattern === 'Array'
	 * @returns {String} The formatted string
	 */
	function getPatternString(pattern, within) {
		if (pattern == null)
			return undefined;

		if (typeof pattern === 'string')
			return pattern;

		// First split the properties into individual words and pair them
		var tokens = [];
		$.each(pattern, function (propIndex, propertyField) {
			if (propertyField.value.length > 0) { // skip empty fields
				var words = propertyField.value.split(/\s+/);
				for (var i = 0; i < words.length; i++) {
					if (!tokens[i])
						tokens[i] = {};

					tokens[i][propertyField.name] = (propertyField['case'] ? '(?-i)' : '') + makeWildcardRegex(words[i]);
				}
			}
		});

		var tokenStrings = [];
		$.each(tokens, function(index, value) {

			// push all attributes in this token
			var attributesStrings = [];
			$.each(value, function (key, value) {
				if (value) // don't push empty attributes
					attributesStrings.push(key + '=' + '"' + value + '"');
			});

			tokenStrings.push('[', attributesStrings.join(' & '), ']');
		});

		if (tokenStrings.length > 0 && within)
			tokenStrings.push(' within ', '<'+ within+'/>');

		return tokenStrings.join('');
	}

	/**
	 * Converts the active filters into a parameter string blacklab-server can understand.
	 *
	 * Values from filters with types other than 'range' or 'select' will be split on whitespace and individual words will be surrounded by quotes.
	 * Effectively transforming
	 * "quoted value" not quoted value
	 * into
	 * "quoted value" "not" "quoted" "value"
	 *
	 * The result of this is that the filter will respond to any value within one set of quotes, so practially an OR on individual words.
	 *
	 * If the array is empty or null, undefined is returned,
	 * so it can be placed directly in the request paremeters without populating the object if the value is not present.
	 *
	 * @param {Array.<FilterField>} [filterArr]
	 * @returns {string} - The converted filters, or undefined if no filters were present.
	 */
	function getFilterString(filterArr) {

		if (filterArr == null || filterArr.length === 0)
			return undefined;

		var filterStrings = [];
		$.each(filterArr, function (index, element) {
			if (filterStrings.length)
				filterStrings.push(' AND ');

			if (element.filterType === 'range') {
				filterStrings.push(element.name, ':', '[', element.values[0], ' TO ', element.values[1], ']');
			} else if (element.filterType === 'select') {
				// Surround each individual value with quotes, and surround the total with brackets
				filterStrings.push(element.name, ':', '("', element.values.join('" "'), '")');
			} else {
				// Do the quoting thing
				var resultParts = [];

				$.each(element.values, function (index, value) {
					var quotedParts = value.split(/"/);
					var inQuotes = false;
					for (var i = 0; i < quotedParts.length; i++) {
						var part = quotedParts[i];
						if (inQuotes) {
							// Inside quotes. Add literally.
							resultParts.push(' "');
							resultParts.push(part);
							resultParts.push('"');
						} else {
							// Outside quotes. Surround each word with quotes.
							part = part.trim();
							if (part.length > 0) {
								var words = part.split(/\s+/);
								resultParts.push(' "');
								resultParts.push(words.join('" "'));
								resultParts.push('" ');
							}
						}
						inQuotes = !inQuotes;
					}
				});

				filterStrings.push(element.name, ':', '(' + resultParts.join('').trim(), ')');
			}
		});

		return filterStrings.join('');
	}

	/**
	 * Central handler for updating the totals display
	 */
	var totalsCounter = (function(){
		// Parameters used in the next update request
		var curUrl;
		var curPageSize;

		// Handles to the current request/scheduled request
		var timeoutHandle = null;
		var inflightRequest = null;

		function scheduleRequest() {
			inflightRequest = $.ajax({
				url: curUrl,
				dataType: 'json',
				cache: false,
				success: function(data) {
					updateTotalsDisplay(data);
					if (data.summary.stillCounting) {
						timeoutHandle = setTimeout(scheduleRequest, 1000);
					} else {
						timeoutHandle = null;
					}
				},
				fail: function() {
					timeoutHandle = null;
				},
				complete: function() {
					inflightRequest = null;
				}
			});
		}

		function cancelRequest() {
			timeoutHandle != null && clearTimeout(timeoutHandle);
			timeoutHandle = null;

			inflightRequest != null && inflightRequest.abort();
			inflightRequest = null;

			$('#totalsReport').hide();
		}

		function updateTotalsDisplay(data) {
			var type;
			var total;

			if (data.summary.numberOfGroups != null) {
				type = 'groups';
				total = data.summary.numberOfGroups;
			} else if (data.hits != null) {
				type = 'hits';
				total = data.summary.numberOfHitsRetrieved;
			} else if (data.docs != null) {
				type = 'docs';
				total = data.summary.numberOfDocsRetrieved;
			}

			var totalPages = Math.ceil(total / curPageSize);

			var optEllipsis = data.summary.stillCounting ? '...' : '';
			$('#totalsReport').show();
			$('#totalsReportText').html(
				'Total ' + type + ': ' + total + optEllipsis + '<br>' +
				'Total pages: ' + totalPages + optEllipsis
			);

			$('#totalsSpinner').toggle(data.summary.stillCounting);
		}

		return {
			/**
			 * Cancel any pending updates from previous requests,
			 * then immediately update the totals display with the results so far.
			 * Starts a background counter that continues updating the display until all results have been counted.
			 *
			 * @param {any} data - the data returned from blacklab-server with the initial request
			 * @param {any} blsParam - The final (processed) blacklab search parameters.
			 * @param {string} operation - The search operation, must not be 'hits' if no pattern supplied.
			 */
			start: function(data, blsParam, operation) {
				cancelRequest();

				// Store the requested page size (to do page number calculation)
				// Then set request page size to 0 so we don't actually retrieve any results
				curPageSize = blsParam.number;
				curUrl = new URI(BLS_URL).segment(operation).addSearch($.extend({},blsParam, {number:0})).toString();
				updateTotalsDisplay(data);

				if (data.summary.stillCounting)
					scheduleRequest();
			},
			stop: cancelRequest,
		};
	})();

	// Return a closure with some request caching variables
	return (function() {
		var inflightRequest = null;

		return {
			/**
			 * Translate SearchParameters to blacklab-server search parameters and perform a search.
			 *
			 * @param {SearchParameters} param - Parameters, these must be in a valid configuration.
			 * @param {BLSSuccess} successFunc
			 * @param {BLSError} errorFunc
			 */
			search: function (param, successFunc, errorFunc) {
				var operation = param.operation;
				var blsParam = SINGLEPAGE.BLS.getBlsParam(param);

				if (SINGLEPAGE.DEBUG) {
					console.log(blsParam);
				}

				inflightRequest = $.ajax({
					url: new URI(BLS_URL).segment(operation).addSearch(blsParam).toString(),
					dataType: 'json',
					cache: false,
					success: function(data) {
						if (SINGLEPAGE.DEBUG) {
							console.log(data);
						}

						// only start when we get the first bit of data back
						// or we would fire off two nearly identical requests for nothing
						totalsCounter.start(data, blsParam, operation);

						if (typeof successFunc === 'function')
							successFunc(data);
					},
					error: function() {
						if (SINGLEPAGE.DEBUG)
							console.log('Request failed: ', arguments);

						if (typeof errorFunc === 'function')
							errorFunc.apply(undefined, arguments);
					},
					complete: function() {
						inflightRequest = null;
					}
				});
			},

			cancelSearch: function() {
				inflightRequest != null && inflightRequest.abort();
				inflightRequest = null;
				totalsCounter.stop();
			},

			/**
			 * Translate SearchParameters to blacklab-server parameters.
			 *
			 * @param {SearchParameters} param - the page parameters.
			 * @returns {BlackLabParameters}
			 */
			getBlsParam: function(param) {
				return {
					// these are always present
					number: param.pageSize,
					first: param.page * param.pageSize,

					sample: (param.sampleMode === 'percentage' && param.sampleSize) ? parseFloat(param.sampleSize) || undefined : undefined,
					samplenum: (param.sampleMode === 'count' && param.sampleSize) ? parseInt(param.sampleSize) || undefined : undefined,
					sampleseed: (param.sampleSeed != null && param.sampleMode && param.sampleSize) ? parseInt(param.sampleSeed) || undefined : undefined,

					// these are either undefined or valid (meaning no empty strings/arrays)
					filter: getFilterString(param.filters),
					group: (param.groupBy || []).join(',') || undefined,
					patt: getPatternString(param.pattern),

					sort: param.sort || undefined,
					viewgroup: param.viewGroup || undefined
				};
			},

			/**
			 * Transform BlackLabParameters into SearchParamers (where supported, blacklab server supports more options than the frontend in some options, so not all options may be mapped cleanly)
			 *
			 * @param {BlackLabParameters} blsParam - (optional) the blacklab search object
			 * @returns {SearchParameters|null} - null if empty or null blsParam
			 */
			getPageParam: function(blsParam) {
				var pageParams = {};
				if (blsParam == null || $.isEmptyObject(blsParam))
					return null;

				pageParams.operation  = blsParam.patt ? 'hits' : 'docs';
				pageParams.sampleSize = blsParam.sample != null ? blsParam.sample : blsParam.samplenum;
				pageParams.sampleMode = blsParam.sample != null ? 'percentage' : blsParam.samplenum != null ? 'count' : undefined;
				pageParams.sampleSeed = blsParam.sampleseed;
				pageParams.page       = blsParam.number != null ? Math.floor((blsParam.first || 0) / blsParam.number) : undefined;
				pageParams.pageSize   = blsParam.number || undefined;
				pageParams.groupBy    = blsParam.group ? blsParam.group.split(',') : undefined;
				pageParams.viewGroup  = blsParam.viewgroup;
				pageParams.sort       = blsParam.sort;

				// Parse the FilterFields from the lucene query, this is a bit involved.
				// TODO factor into module and add tests.
				pageParams.filters = (function() {
					if (!blsParam.filter)
						return null;

					if (SINGLEPAGE.DEBUG)
						console.log('parsing filter string', blsParam.filter);

					// First define some structures returned by the lib so we actually know what we're working with

					/**
					 * @typedef Node
					 * @property {(Node|Field|Range)} left
					 * @property {('OR' | 'AND' | 'NOT' | '-' | '+')} operator - multiple operators in the same position are not supported e.g. (a OR NOT b)
					 * @property {(Node|Field|Range)} right
					 * @property {string} [field] - field name (for field group syntax)
					 */

					/**
					 * @typedef Field
					 * @property {string} field - field name, '<implicit>' if unspecified (then use field of nearest ancestor that defines it, if there's none, it's the default lucene field)
					 * @property {string} term
					 * @property {('+' | '-')} [prefix]
					 * @property {number} [boost]
					 * @property {number} [similarity] - 0<similarity<1
					 * @property {number} [promity]
					 */

					/**
					 * @typedef Range
					 * @property {string} field - field name, '<implicit>' if unspecified
					 * @property {string} term_min
					 * @property {string} term_max
					 * @property {boolean} inclusive - inclusive_min && inclusive_max
					 * @property {boolean} inclusive_min - inclusive lower bound
					 * @property {boolean} inclusive_max - inclusive upper bound
					 */

					/**
					 * Since the parsed query is a tree-like structure (to allow expression like 'field:("value1" OR ("value3" OR "value4"))' )
					 * We need to recurse to extract all the values.
					 * To simplify keeping track of what part of the query we're parsing, we store the current field here.
					 * @type {FilterField}
					 */
					var context = null;
					/** 
					 * Once we're done with a field, we store it here and clear the context.
					 * @type {Array.<FilterField>} 
					 */
					var parsedValues = [];

					/** 
					 * Process a Node. A Field object is always contained within a Node (as far as I can tell).
					 * So for a simple query like 'field:value', the library returns a structure like:
					 * ```
					 * { // Node
					 *   field: 'field',
					 *   left: { // Field
					 *     field: '<implicit>', // referring to property 'field' in the enclosing Node structure
					 *     term: 'value'
					 *    }
					 * }
					 * ```
					 * So if the Node contains a 'field' property we know all children will be Field instances defining the values
					 * and we can open a new context that we can store the values in later parsing steps.
					 * @param {Node} val 
					 */
					function node(val) {
						if (val == null)
							return;

						var createdContext = false;
						if (val.field) {
							// if there is no context yet, the field can still be <implicit>, in this case we'd expect that the left node
							// defines the field name, this is the case with range expression, so we will define the context when processing the left node.
							if (context == null && val.field && val.field !== '<implicit>') {
								context = {
									name: val.field,
									filterType: 'select',
									values: []
								};
								createdContext = true;
							} else if (context != null && val.field && val.field !== '<implicit>') {
								// this is weird, and it should probably never happen
								// it would mean we're going to define terms for a field while we're already inside the term list expression for another field
								if (SINGLEPAGE.DEBUG) {
									console.log('Got a node with a field, but already have context, ignoring.', context);
									debugger;
								}
								return;
							}
						}

						var cur = val.left; // left always present
						if ('left' in cur) node(cur);
						else if ('term' in cur) field(cur);
						else if ('term_min' in cur) range(cur);

						/**
						 * We need to know what the right side contains if we're to handle it.
						 * - If have a context, that means both left and right are values for a specific field (or Nodes containg a subtree of multiple values).
						 * The current Node is the OR/AND token in a query like 'field:("value" OR "value2")'
						 * The interface can only handle OR'ing all values for a field, so check that the query doesn't specify AND,
						 * and if it does then skip processing the right side of the tree. 
						 * - If we _don't_ have a context, then left and right define the Fields themselves 
						 * The current Node is then the OR/AND token in a query like 'field1:value1 AND field2:value2'
						 * In thise case, the interface can only handle AND'ing all the different fields, so check that too.
						 */
						if (val.right && 
							((context == null && !(val.operator === 'OR' || val.operator === '<implicit>')) || // implicit operator between field means OR
							(context != null && !(val.operator == 'AND' )))
						) { 
							cur = val.right;
							if ('left' in cur) node(cur);
							else if ('term' in cur) field(cur);
							else if ('term_min' in cur) range(cur);
						}

						if (createdContext) {
							if (context == null) {
								if (SINGLEPAGE.DEBUG) {
									console.log('We started a context but didn\'t end with one, some other function pushed it, that shouldn\'t happen...');
									debugger;
								}
							} else {
								parsedValues.push(context);
								context = null;
							}
						}
						// else we're already inside inside an existing context and are just recursing over the values
					}

					/**
					 * @param {Field} val
					 */
					function field(val) {
						if (field == null)
							return;

						var createdContext = false;
						if (context == null) {
							if (val.field === '<implicit>') // default field name, query only specifies a value but no field, such as the query 'value', interface can't display this
								return;

							context = {
								name: val.field,
								filterType: 'text',
								values: []
							};
							createdContext = true;
						} else if (context != null && val.field && val.field !== '<implicit>') {
							if (SINGLEPAGE.DEBUG) {
								console.log('Got field', field, ' with an explicit name, but we already have a context?');
								debugger;
							}
							return;
						} // else have context and field is implicit, just add the term value to the list

						context.values.push(val.term);
						if (createdContext) {
							parsedValues.push(context);
							context = null;
						}
					}

					/**
					 * @param {Range} val
					 */
					function range(val) {
						if (val == null)
							return;

						if (context != null) {
							// mixed terms and ranges for the same field, can't handle.
							if (SINGLEPAGE.DEBUG) {
								console.log('Entered a range expression, but context is not null, might happen? cannot handle in interface');
								debugger;
							}
							return;
						}
						if (val.field === '<implicit>') // default value, basically parsing "[from TO to]" without the name of field to which to apply the range, interface can't handle this
							return;

						// Ignore in/exclusivity
						parsedValues.push({
							name: val.field,
							filterType: 'range',
							values: [val.term_min, val.term_max]
						});
					}

					try {
						var results = lucenequeryparser.parse(blsParam.filter);
						node(results);
						return parsedValues.length ? parsedValues : null;
					} catch (error) {
						if (SINGLEPAGE.DEBUG) {
							console.log('Could not parse lucene query ' + blsParam.filter);
							console.log('reason: ', error);
						}
						return null;
					}
				})();

				/**
				 * Attempt to parse the cql-query into an array of PropertyFields as used by the simple search tab.
				 * This only works for the most simple of queries.
				 * Essentially do the inverse of getPatternString.
				 * 
				 * Also sets the pageParams.within, since it's encoded in the cql query.
				 * 
				 * If parsing fails, or the query is too complex, we just return the raw query, it can still be displayed/used elsewhere.
				 */
				pageParams.pattern = (function() {
					function isCase(value) { return value.startsWith('(?-i)') || value.startsWith('(?c)'); }
					function stripCase(value) { return value.substr(value.startsWith('(?-i)') ? 5 : 4); }
					
					try {
						var result = SINGLEPAGE.CQLPARSER.parse(blsParam.patt);
						pageParams.within = result.within;

						/**
						 * A requirement of the PropertyFields is that there are no gaps in the values
						 * So a valid config is 
						 * ```
						 * lemma: [these, are, words]
						 * word: [these, are, other, words]
						 * ```
						 * And an invalid config is
						 * ```
						 * lemma: [gaps, are, , not, allowed]
						 * ```
						 * Not all properties need to have the same number of values though, 
						 * shorter lists are implicitly treated as having wildcards for the remainder of values. (see getPatternString())
						 * 
						 * Store the values here while parsing.
						 * 
						 * @type Object.<string, Array.<String>> 
						 */
						var attributeValues = {};

						for (var i = 0; i < result.tokens.length; ++i) {
							/** @type {Token} */
							var token = result.tokens[i];

							if (token.leadingXmlTag || token.optional || token.repeats || token.trailingXmlTag)
								throw new Error('Token contains settings too complex for simple search');

							// Use a stack instead of direct recursion to simplify code
							var stack = [token.expression];
							while (stack.length) {
								var expr = stack.shift();
								if (expr.type === 'attribute') {
									var name = expr.name;
									var values = attributeValues[name] = attributeValues[name] || [];
									if (expr.operator != '=')
										throw new Error('Unsupported comparator, only "=" is supported.');
									if (values.length !== i)
										throw new Error('Duplicate or missing values on property');
									values.push(expr.value);
								} else if (expr.type === 'binaryOp') {
									if (!(expr.operator === '&' || expr.operator === 'AND'))
										throw new Error('Multiple properties on token must use AND operator');

									stack.push(expr.left, expr.right);
								}
							}
						}

						/**
						 * Build the actuals PropertyFields.
						 * Convert from regex back into pattern globs, extract case sensitivity.
						 * 
						 * @type {Array.<PropertyField>} 
						 */
						var propertyFields = [];
						$.each(attributeValues, function(attrName, attrValues) {
							var caseSensitive = attrValues.every(isCase);
							if (caseSensitive)
								attrValues = attrValues.map(stripCase);
							
							propertyFields.push({
								name: attrName,
								case: caseSensitive,
								value: makeRegexWildcard(attrValues.join(' '))
							});
						});

						return propertyFields;
					} catch (error) {
						if (SINGLEPAGE.DEBUG)
							console.log('Coult not parse cql query', blsParam.patt);
						pageParams.within = null; // couldn't parse
						return blsParam.patt; // just pass on the cql-query, we can't parse it, or it's too complex
					}
				})();

				return pageParams;
			},

			/**
			 * Get a human-readable summary of the most important search parameters
			 * Arguments must be equal to the same members of the SearchParameters object
			 *
			 * @param {(string | Array.<PropertyField>)} pattern - A direct CQL query string, or an array of simple search paremeters. This value MUST be present if operation === 'hits'
			 * @param {string} within - raw token name (i.e. not enclosed in </>) for the within clause (so 'p' for paragraph, 's' for sentence, etc), only used when typeof pattern === 'Array'
			 * @param {Array.<FilterField>} filters - Metadata filters as generated by singlepage-form.js, every filter is expected to have a valid value.
			 */
			getQuerySummary: function(pattern, within, filters) {
				var queryString = getPatternString(pattern, within);
				var metadataString = $.map(filters, function(filter) {
					return filter.name + ' = [' +
						(filter.filterType === 'range'
							? filter.values[0] + ' to ' + filter.values[1]
							: filter.values.join(', '))
							+ ']';
				}).join(', ');

				var ret = '';
				if (queryString) {
					ret += '"' + queryString + '"' + ' within ';
				}
				if (metadataString)
					ret += 'documents where ' + metadataString;
				else
					ret += 'all documents';

				return ret;
			}
		};
	})();
})();
